<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>جستجوی کتاب‌های خطی فارسی</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/vue@3"></script>
  <style>
    /* تنظیمات فونت برای کل بدنه */
    body {
      font-family: 'Inter', sans-serif; /* استفاده از فونت Inter یا فونت‌های جایگزین sans-serif */
    }
    /* تنظیمات حالت تاریک */
    @media (prefers-color-scheme: dark) {
      html {
        color-scheme: dark;
      }
      body {
        background-color: #1f2937; /* پس‌زمینه خاکستری تیره */
        color: white; /* متن سفید */
      }
    }
    /* استایل‌دهی برای عناصر دارای گوشه‌های گرد */
    .rounded-lg, .rounded {
      border-radius: 0.5rem; /* گوشه‌های گرد استاندارد */
    }
    /* استایل‌دهی برای دکمه‌ها */
    button {
      transition: background-color 0.2s ease-in-out; /* انیمیشن نرم برای تغییر رنگ پس‌زمینه */
    }
    /* استایل‌دهی برای ورودی‌ها و انتخابگرها */
    input, select {
      border-color: #d1d5db; /* رنگ خاکستری روشن برای حاشیه */
    }
    .dark input, .dark select {
      background-color: #374151; /* پس‌زمینه خاکستری تیره در حالت تاریک */
      color: white; /* متن سفید در حالت تاریک */
      border-color: #4b5563; /* حاشیه خاکستری تیره‌تر در حالت تاریک */
    }
    .filter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    .show-all-btn {
      background-color: #3b82f6; /* آبی */
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      cursor: pointer;
      border: none;
    }
    .show-all-btn:hover {
      background-color: #2563eb; /* آبی تیره‌تر در هاور */
    }
  </style>
</head>
<body>
  <!-- افزایش عرض کلی ابزار به max-w-screen-xl و تنظیم padding -->
  <div id="app" class="p-6 max-w-screen-xl mx-auto" dir="rtl">
    <h1 class="text-3xl font-bold mb-6 text-center">جستجوی کتاب‌های خطی فارسی</h1>

    <div class="grid grid-cols-1 md:grid-cols-4 gap-6">

      <!-- نوار کناری فیلترها -->
      <div class="md:col-span-1 bg-white dark:bg-gray-800 p-4 rounded-lg shadow text-sm space-y-6">
        <!-- فیلتر پدیدآورندگان پرتکرار -->
        <div>
          <div class="filter-header">
            <h2 class="font-bold">پدیدآورندگان پرتکرار</h2>
            <button @click="showAllAuthors = !showAllAuthors" class="show-all-btn">
              {{ showAllAuthors ? 'نمایش ۱۰ مورد' : 'نمایش همه' }}
            </button>
          </div>
          <ul>
            <li v-for="([author, count], i) in topAuthors" :key="i" class="cursor-pointer hover:text-blue-600"
                @click="filters.author = author">
              {{ author }} ({{ toPersianDigits(count) }})
            </li>
          </ul>
        </div>
        <!-- فیلتر ناشران پرتکرار (بر اساس فیلد publisher1) -->
        <div>
          <div class="filter-header">
            <h2 class="font-bold">ناشران پرتکرار</h2>
            <button @click="showAllPublishers = !showAllPublishers" class="show-all-btn">
              {{ showAllPublishers ? 'نمایش ۱۰ مورد' : 'نمایش همه' }}
            </button>
          </div>
          <ul>
            <li v-for="([pub1, count], i) in topPublishers" :key="i" class="cursor-pointer hover:text-blue-600"
                @click="filters.publisher1 = pub1">
              {{ pub1 }} ({{ toPersianDigits(count) }})
            </li>
          </ul>
        </div>
        <!-- فیلتر انواع پرتکرار -->
        <div>
          <div class="filter-header">
            <h2 class="font-bold">انواع پرتکرار</h2>
            <button @click="showAllTypes = !showAllTypes" class="show-all-btn">
              {{ showAllTypes ? 'نمایش ۱۰ مورد' : 'نمایش همه' }}
            </button>
          </div>
          <ul>
            <li v-for="([type, count], i) in topTypes" :key="i" class="cursor-pointer hover:text-blue-600"
                @click="filters.type = type">
              {{ type }} ({{ toPersianDigits(count) }})
            </li>
          </ul>
        </div>
        <!-- فیلتر سال‌های میلادی پرتکرار -->
        <div>
          <div class="filter-header">
            <h2 class="font-bold">سال‌های میلادی پرتکرار</h2>
            <button @click="showAllGregorianYears = !showAllGregorianYears" class="show-all-btn">
              {{ showAllGregorianYears ? 'نمایش ۱۰ مورد' : 'نمایش همه' }}
            </button>
          </div>
          <ul>
            <li v-for="([year, count], i) in topGregorianYears" :key="i" class="cursor-pointer hover:text-blue-600"
                @click="filters.gregorianYear = year">
              {{ toPersianDigits(year) }} ({{ toPersianDigits(count) }})
            </li>
          </ul>
        </div>
        <!-- فیلتر سال‌های قمری پرتکرار -->
        <div>
          <div class="filter-header">
            <h2 class="font-bold">سال‌های قمری پرتکرار</h2>
            <button @click="showAllHijriYears = !showAllHijriYears" class="show-all-btn">
              {{ showAllHijriYears ? 'نمایش ۱۰ مورد' : 'نمایش همه' }}
            </button>
          </div>
          <ul>
            <li v-for="([year, count], i) in topHijriYears" :key="i" class="cursor-pointer hover:text-blue-600"
                @click="filters.hijriYear = year">
              {{ toPersianDigits(year) }} ({{ toPersianDigits(count) }})
            </li>
          </ul>
        </div>
      </div>

      <!-- بخش اصلی محتوا -->
      <div class="md:col-span-3">
        <!-- نوار جستجو و مرتب‌سازی -->
        <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow mb-4">
          <div class="flex flex-wrap items-center gap-2 mb-2">
            <input type="text" v-model="search" placeholder="جستجو..."
                   class="flex-grow p-2 border rounded focus:outline-none text-black dark:text-white dark:bg-gray-700 dark:border-gray-600">
            <select v-model="sortKey" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white">
              <option value="title">عنوان</option>
              <option value="author">پدیدآور</option>
              <option value="publisher1">ناشر</option>
              <option value="type">نوع</option>
              <option value="date">تاریخ</option>
              <option value="hijridate">تاریخ قمری</option>
              <option value="catid">شماره کاتالوگ</option> <!-- اضافه شدن شماره کاتالوگ به مرتب‌سازی -->
              <option value="id">شماره راهنما</option> <!-- اضافه شدن شماره راهنما به مرتب‌سازی -->
            </select>
            <select v-model="sortOrder" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white">
              <option value="asc">صعودی</option>
              <option value="desc">نزولی</option>
            </select>
            <button @click="resetFilters"
                    class="bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600">پاک‌سازی</button>
          </div>
          <p class="text-gray-700 dark:text-gray-300">
            نمایش {{ toPersianDigits(displayedBooks.length) }} نتیجه
            <span v-if="searchActive" class="text-gray-700 dark:text-gray-300">از {{ toPersianDigits(filteredBooks.length) }}</span>
            <span v-if="searchActive && filteredBooks.length > 200" class="text-orange-500">(فقط ۲۰۰ نتیجه اول نمایش داده می‌شود)</span>
            <span v-else-if="!searchActive" class="text-gray-700 dark:text-gray-300">(۱۰۰ نتیجه تصادفی)</span>
          </p>
        </div>

        <!-- نمایش نتایج جستجو - تغییر به سه ستون در اندازه‌های متوسط به بالا -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div v-for="(book, i) in displayedBooks" :key="book.catid || i"
               class="bg-white dark:bg-gray-900 p-4 rounded-lg shadow border border-gray-200 dark:border-gray-700">
            <!-- عنوان آیتم که به لینک کاتالوگ پیوند دارد -->
            <h2 class="font-bold text-blue-700 text-lg mb-1">
              <a :href="`https://lib.ut.ac.ir/site/catalogue/${book.catid}`" target="_blank"
                 class="hover:underline">{{ book.title }}</a>
            </h2>
            <!-- نوع و محل نگهداری در دو بلوک کوچک -->
            <div class="flex flex-wrap gap-2 mb-2">
              <span v-if="book.type" class="bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-200 text-xs font-medium px-2.5 py-0.5 rounded-full">
                {{ book.type }}
              </span>
              <span v-if="book.db" class="bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200 text-xs font-medium px-2.5 py-0.5 rounded-full">
                {{ book.db }}
              </span>
            </div>

            <!-- نمایش سایر پارامترها با برچسب فارسی -->
            <p v-if="book.author" class="mb-1">
              پدیدآور:
              <a v-if="book.authoritem" :href="`https://www.wikidata.org/wiki/${book.authoritem}`" target="_blank" class="text-blue-600 hover:underline">
                {{ book.author }}
              </a>
              <span v-else>{{ book.author }}</span>
            </p>
            <p v-if="book.publisher1" class="mb-1">ناشر: {{ book.publisher1 }}</p>
            <!-- حذف کلمه «اصلی» از عنوان تاریخ انتشار -->
            <p v-if="book.date" class="mb-1">تاریخ انتشار: {{ book.date }}</p>
            <p v-if="book.gregorianyear" class="mb-1">سال میلادی: {{ toPersianDigits(book.gregorianyear) }}</p>
            <!-- نمایش تاریخ قمری با فرمت جدید و روز هفته -->
            <p v-if="book.hijridate || book.weekday" class="mb-1">
              تاریخ قمری: {{ formatHijriDate(book.hijridate, book.weekday) }}
            </p>
            <p v-if="book.id" class="mb-1">شماره راهنما: {{ book.id }}</p>
            <p v-if="book.catid" class="mb-1">
              شماره کاتالوگ:
              <a :href="`https://lib.ut.ac.ir/site/catalogue/${book.catid}`" target="_blank"
                 class="text-blue-600 hover:underline">{{ book.catid }}</a>
            </p>
          </div>
        </div>

      </div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;
    createApp({
      data() {
        return {
          books: [], // آرایه اصلی کتاب‌ها
          search: '', // متن جستجو
          sortKey: 'title', // کلید مرتب‌سازی پیش‌فرض
          sortOrder: 'asc', // ترتیب مرتب‌سازی پیش‌فرض
          filters: { // آبجکت فیلترها
            author: null,
            publisher1: null, // فیلتر برای publisher1
            type: null,
            gregorianYear: null, // فیلتر جدید برای سال میلادی
            hijriYear: null      // فیلتر جدید برای سال قمری
          },
          // وضعیت نمایش همه موارد در سایدبار
          showAllAuthors: false,
          showAllPublishers: false, // برای publisher1
          showAllTypes: false,
          showAllGregorianYears: false,
          showAllHijriYears: false
        }
      },
      computed: {
        // بررسی فعال بودن جستجو یا فیلترها
        searchActive() {
          return this.search !== '' ||
                 Object.values(this.filters).some(filter => filter !== null);
        },
        // کتاب‌های فیلتر شده و مرتب شده (قبل از محدودیت نتایج)
        filteredBooks() {
          let result = this.books.filter(b => {
            const term = this.search.toLowerCase(); // تبدیل متن جستجو به حروف کوچک
            // بررسی فیلتر پدیدآورنده
            const matchesAuthor = !this.filters.author || b.author === this.filters.author;
            // بررسی فیلتر ناشر (اکنون به publisher1 اعمال می‌شود)
            const matchesPublisher1 = !this.filters.publisher1 || b.publisher1 === this.filters.publisher1;
            // بررسی فیلتر نوع
            const matchesType = !this.filters.type || b.type === this.filters.type;
            // بررسی فیلتر سال میلادی (با توجه به وجود فیلد date)
            const matchesGregorianYear = !this.filters.gregorianYear || (b.date && b.date.includes(this.filters.gregorianYear));
            // بررسی فیلتر سال قمری (با توجه به وجود فیلد hijridate)
            const matchesHijriYear = !this.filters.hijriYear || (b.hijridate && b.hijridate.includes(this.filters.hijriYear));

            // بررسی مطابقت با متن جستجو در فیلدهای مختلف
            const matchesSearchTerm = (b.title?.toLowerCase().includes(term) ||
                                       b.author?.toLowerCase().includes(term) ||
                                       b.id?.toLowerCase().includes(term) ||
                                       b.publisher1?.toLowerCase().includes(term) || // جستجو در publisher1
                                       b.publisher?.toLowerCase().includes(term) || // همچنان جستجو در publisher اصلی
                                       b.type?.toLowerCase().includes(term) ||
                                       b.db?.toLowerCase().includes(term));

            // بازگرداندن نتایجی که با تمام فیلترها و متن جستجو مطابقت دارند
            return matchesAuthor && matchesPublisher1 && matchesType &&
                   matchesGregorianYear && matchesHijriYear && matchesSearchTerm;
          });

          // مرتب‌سازی نتایج
          result.sort((a, b) => {
            let valA = (a[this.sortKey] || '').toString().toLowerCase();
            let valB = (b[this.sortKey] || '').toString().toLowerCase();
            // برای مرتب‌سازی عددی id و catid
            if (this.sortKey === 'id' || this.sortKey === 'catid') {
                valA = parseInt(valA, 10) || 0;
                valB = parseInt(valB, 10) || 0;
                return this.sortOrder === 'asc' ? valA - valB : valB - valA;
            }
            return this.sortOrder === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
          });

          return result;
        },
        // کتاب‌های نمایش داده شده (۱۰۰ تصادفی یا ۲۰۰ فیلتر شده)
        displayedBooks() {
          if (!this.searchActive) {
            // نمایش ۱۰۰ نتیجه تصادفی در حالت اولیه
            return this.shuffleArray([...this.books]).slice(0, 100);
          } else {
            // نمایش حداکثر ۲۰۰ نتیجه فیلتر شده
            return this.filteredBooks.slice(0, 200);
          }
        },
        // محاسبه پرتکرارترین پدیدآورندگان بر اساس نتایج فیلتر شده
        topAuthors() {
          return this.getTopCounts(this.filteredBooks, 'author', 10, this.showAllAuthors);
        },
        // محاسبه پرتکرارترین ناشران (اکنون بر اساس فیلد publisher1) بر اساس نتایج فیلتر شده
        topPublishers() {
          return this.getTopCounts(this.filteredBooks, 'publisher1', 10, this.showAllPublishers);
        },
        // محاسبه پرتکرارترین انواع بر اساس نتایج فیلتر شده
        topTypes() {
          return this.getTopCounts(this.filteredBooks, 'type', 10, this.showAllTypes);
        },
        // محاسبه پرتکرارترین سال‌های میلادی بر اساس نتایج فیلتر شده
        topGregorianYears() {
          const years = {};
          this.filteredBooks.forEach(b => { // استفاده از filteredBooks
            if (b.date) {
              const yearMatch = b.date.match(/\d{4}/);
              if (yearMatch) {
                const year = yearMatch[0];
                years[year] = (years[year] || 0) + 1;
              }
            }
          });
          const sortedYears = Object.entries(years).sort((a, b) => b[1] - a[1]);
          return this.showAllGregorianYears ? sortedYears : sortedYears.slice(0, 10);
        },
        // محاسبه پرتکرارترین سال‌های قمری بر اساس نتایج فیلتر شده
        topHijriYears() {
          const years = {};
          this.filteredBooks.forEach(b => { // استفاده از filteredBooks
            if (b.hijridate) {
              const yearMatch = b.hijridate.match(/\d{4}/);
              if (yearMatch) {
                const year = yearMatch[0];
                years[year] = (years[year] || 0) + 1;
              }
            }
          });
          const sortedYears = Object.entries(years).sort((a, b) => b[1] - a[1]);
          return this.showAllHijriYears ? sortedYears : sortedYears.slice(0, 10);
        }
      },
      methods: {
        // واکشی داده‌های کتاب‌ها از فایل JSON
        async fetchBooks() {
          try {
            const res = await fetch('./utlibrary-alldata.json');
            if (!res.ok) {
              throw new Error(`HTTP error! status: ${res.status}`);
            }
            this.books = await res.json();
          } catch (error) {
            console.error("Error fetching books:", error);
            // می‌توانید یک پیام خطا به کاربر نمایش دهید
          }
        },
        // بازنشانی تمام فیلترها و جستجو
        resetFilters() {
          this.search = '';
          this.sortKey = 'title';
          this.sortOrder = 'asc';
          this.filters = {
            author: null,
            publisher1: null,
            type: null,
            gregorianYear: null,
            hijriYear: null
          };
          // بازنشانی وضعیت نمایش همه موارد در سایدبار
          this.showAllAuthors = false;
          this.showAllPublishers = false;
          this.showAllTypes = false;
          this.showAllGregorianYears = false;
          this.showAllHijriYears = false;
        },
        // تابعی برای محاسبه تعداد تکرار هر مقدار در یک فیلد خاص
        // این تابع اکنون لیست کتاب‌ها را به عنوان آرگومان اول می‌پذیرد
        getTopCounts(booksList, key, defaultLimit = 10, showAllFlag = false) {
          const counts = {};
          booksList.forEach(b => { // استفاده از booksList به جای this.books
            const val = b[key];
            if (val) counts[val] = (counts[val] || 0) + 1;
          });
          const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
          return showAllFlag ? sorted : sorted.slice(0, defaultLimit);
        },
        // تبدیل ارقام لاتین به ارقام فارسی
        toPersianDigits(str) {
          return String(str).replace(/\d/g, d => '۰۱۲۳۴۵۶۷۸۹'[d]);
        },
        // تابعی برای تصادفی کردن آرایه (Fisher-Yates shuffle)
        shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
          }
          return array;
        },
        // تابعی برای فرمت‌بندی تاریخ قمری
        formatHijriDate(hijriDateStr, weekday) {
            if (!hijriDateStr) return '';

            let year = '';
            let monthNum = null;
            let day = '';

            // حذف کاراکترهای غیر عددی و تبدیل به حروف بزرگ برای یکپارچگی 'X'
            const cleanDateStr = String(hijriDateStr).replace(/[^0-9X]/gi, '').toUpperCase();

            // استخراج بخش‌های تاریخ بر اساس طول رشته
            if (cleanDateStr.length >= 8) { // فرض بر YYYYMMDD
                const y = cleanDateStr.substring(0, 4);
                const m = cleanDateStr.substring(4, 6);
                const d = cleanDateStr.substring(6, 8);
                if (y !== 'XXXX' && y !== 'XX') year = this.toPersianDigits(y);
                if (m !== 'XX') monthNum = parseInt(m, 10);
                if (d !== 'XX') day = this.toPersianDigits(d);
            } else if (cleanDateStr.length >= 6) { // فرض بر YYMMDD
                const y = cleanDateStr.substring(0, 2);
                const m = cleanDateStr.substring(2, 4);
                const d = cleanDateStr.substring(4, 6);

                if (y !== 'XX') {
                    let parsedYear = parseInt(y, 10);
                    if (!isNaN(parsedYear)) {
                         // فرض بر قرن ۱۳۰۰ برای سال‌های ۲ رقمی قمری
                        if (parsedYear < 100) {
                            parsedYear += 1300;
                        }
                        year = this.toPersianDigits(parsedYear);
                    }
                }
                if (m !== 'XX') monthNum = parseInt(m, 10);
                if (d !== 'XX') day = this.toPersianDigits(d);
            } else if (cleanDateStr.length >= 5) { // فرض بر YMMDD
                const y = cleanDateStr.substring(0, 1);
                const m = cleanDateStr.substring(1, 3);
                const d = cleanDateStr.substring(3, 5);

                if (y !== 'X') {
                    let parsedYear = parseInt(y, 10);
                    if (!isNaN(parsedYear)) {
                        // فرض بر قرن ۱۳۰۰ برای سال‌های ۱ رقمی قمری
                        if (parsedYear < 10) {
                            parsedYear += 1300;
                        }
                        year = this.toPersianDigits(parsedYear);
                    }
                }
                if (m !== 'XX') monthNum = parseInt(m, 10);
                if (d !== 'XX') day = this.toPersianDigits(d);
            } else if (cleanDateStr.length === 4) { // فرض بر YYYY (فقط سال)
                const y = cleanDateStr.substring(0, 4);
                if (y !== 'XXXX' && y !== 'XX') year = this.toPersianDigits(y);
            }
            // اگر طول رشته کمتر از این‌ها باشد یا شامل 'X' در بخش‌های دیگر باشد، آن بخش‌ها نادیده گرفته می‌شوند.

            const hijriMonths = [
                '', 'محرم', 'صفر', 'ربیع‌الاول', 'ربیع‌الثانی', 'جمادی‌الاول', 'جمادی‌الثانی',
                'رجب', 'شعبان', 'رمضان', 'شوال', 'ذی‌القعده', 'ذی‌الحجه'
            ];

            let formattedDateParts = [];
            if (weekday) {
                const persianWeekdays = {
                    'saturday': 'شنبه', 'sunday': 'یکشنبه', 'monday': 'دوشنبه',
                    'tuesday': 'سه‌شنبه', 'wednesday': 'چهارشنبه', 'thursday': 'پنجشنبه',
                    'friday': 'جمعه'
                };
                formattedDateParts.push(persianWeekdays[weekday.toLowerCase()] || weekday);
            }
            if (day) formattedDateParts.push(day);
            if (monthNum && hijriMonths[monthNum]) formattedDateParts.push(hijriMonths[monthNum]);
            if (year) formattedDateParts.push(year);

            return formattedDateParts.join(' ');
        }
      },
      mounted() {
        // فراخوانی تابع واکشی کتاب‌ها هنگام بارگذاری کامپوننت
        this.fetchBooks();
      }
    }).mount('#app')
  </script>
</body>
</html>
